# 操作系统基础  
### 1 慢系统调用  

慢系统调用阻塞过程中会被信号中断，EINTR中断了的系统调用是没有完成的调用，它的失败是临时性的，如果再次调用则可能成功，这并不是真正的失败，   

### 2 守护进程创建步骤    

   1. 创建子进程，父进程退出  所有工作在子进程中进行 形式上脱离了控制终端 
    
　　2. 在子进程中创建新会话   setsid()函数  使子进程完全独立出来，脱离控制  
    
　　3. 改变当前目录为根目录  chdir()函数  防止占用可卸载的文件系统 也可以换成其它路径  
    
　　4. 重设文件权限掩码   umask()函数  防止继承的文件创建屏蔽字拒绝某些权限 增加守护进程灵活性  
    
　　5. 关闭文件描述符   继承的打开文件不会用到，浪费系统资源，无法卸载 getdtablesize()    
### 3 时钟中断频率不是越高越好  

 提高时钟中断频率也会产生副作用，中断频率越高，系统的负担就增加了，处理器需要花时间来执行中断处理程序，中断处理器占用cpu时间越多。这样处理器执行其他工作的时间及越少，并且还会打乱处理器高速缓存。                                                                                           所以选择时钟中断频率时要考虑多方面，要取得各方面的折中的一个合适频率。

### 4 内核内存碎片   
内核中使用伙伴算法的迁移机制很好的解决了外部碎片。  

内核中引入了slab机制去尽力的减少内部碎片。  
### 5 linux session（会话） 
一个用户登录到主机，那么就建立了一个session，但是它的维系是基于连接的。  
本地连接：就是说用户是在主机本机上进行的登录，直接通过键盘和屏幕和主机进行交互。  
远程连接：用户通过互联网进行连接，比如基于ssh，连接都是经过加密的。  
session是一个或多个进程组的集合。
当session 中leader进程退出，将导致它所连接终端被hangup，终端被修改为不可读不可写的文件，这就意味着该会话结束   
对于daemon（守护）进程，在会话中创建，但是不依赖于会话，是常驻在后台的进程。  
### 6 内核物理内存管理  
内核采用了三种机制将高端内存映射到内核空间：永久内核映射，固定映射和vmalloc机制。 

内核中物理内存的管理机制主要有伙伴算法，slab高速缓存和vmalloc机制。其中伙伴算法和slab高速缓存都在物理内存映射区分配物理内存，而vmalloc机制则在高端内存映射区分配物理内存  

通用缓存则是针对一般情况，适合分配任意大小的物理内存，其接口即为kmalloc()
### 7 slab内存分配  
每次分配内存都是直接与本地cpu高速缓存进行交互，只有当其空闲内存不足时，才会从keme_list中的slab中引入一部分对象到本地高速缓存中，而keme_list中的空闲对象也不足时，那么就要从伙伴系统中引入新的页来建立新的slab了。  
slab在将某个对象使用完之后，将其缓存起来，它还是切切实实的存在于内存中。   
对象分配的次序为：    
特定于CPU/节点的缓存列表中的对象。  
当前已经存在于slab缓存中中的未用对象。 
从伙伴系统获得内存，然后创建的对象。
###  8 slab的优点  
1 可以提供小块内存的分配支持  

2 不必每次申请释放都和伙伴系统打交道，提高了分配释放效率  

3 如果在slab缓存的话，其在CPU高速缓存的概率也会较高。  

4 伙伴系统的操作对系统的数据和指令高速缓存有影响，slab分配器降低了这种副作用  

5 伙伴系统分配的页地址都页的倍数，这对CPU的高速缓存的利用有负面影响，页首地址对齐在页面大小上使得如果每次都将数据存放到从伙伴系统分配的页开始的位置会使得高速缓存的有的行被过度使用，而有的行几乎从不被使用。slab分配器通过着色使得slab对象能够均匀的使用高速缓存，提高高速缓存的利用率  

### 9 软链接特点

不论是修改源文件（check），还是修改软链接文件（check-soft)，另一个文件中的数据都会发生改变。  

删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。  

软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。  

软链接可以链接目录。  

软链接可以跨分区    

### 10 扩展分区

主分区和扩展分区加起来最多只能建立 4 个，而扩展分区最多只能建立 1 个
扩展分区是不能被格式化和直接使用的，所以还要在扩展分区内部再建立逻辑分区。  

### 11 Linux SetUID 的功能  

只有可以执行的二进制程序才能设定 SetUID 权限。  
命令执行者要对该程序拥有 x（执行）权限。  
命令执行者在执行该程序时获得该程序文件属主的割分（在执行程序的过程中变为文件的属主）。  
SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效。
  
 ### 12 Linux cp命令  
 
 cp命令 ：如果在复制软链接文件时不使用”-d"选项，则 cp 命令复制的是源文件，而不是软链接文件；只有加入了”-d"选项，才会复制软链接文件。注意 "-d"选项对硬链接是无效的。  
 
 ### 13 Linux建立主分区
  
 "fdisk 硬盘名 -> n(新建)->p(建立主分区) -> 1(指定分区号) -> 回车（默认从 1 柱面开始建立分区）-> +5G(指定分区大小)”  
 当然，分区还没有格式化和挂载，所以还不能使用。


