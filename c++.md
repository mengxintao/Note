# c++语言基础  

在函数调用中不允许转递一个临时对象到一个非 const 引用类型的参数里，但是在异常中却被允许。 

### RAII 
资源获取即初始化，在构造函数中申请分配资源，在析构函数中释放资源。RAII核心思想是将资源或者状态与对象的生命周期绑定。使用类来管理资源，将资源和对象的生命周期绑定，不用担心代码异常造成的线程死锁。weak_ptr作为shared_ptr的辅助指针使用，可以解决循环链表中的死锁问题。   

### boost::scoped_ptr   
保证在离开作用域之后它所管理对象能被自动释放，scoped_ptr不能通过其他scoped_ptr共享控制权，因为在scoped_ptr类的内部将拷贝构造函数和=运算符重载定义为私有的。所以，scoped_ptr不能用在标准库的容器中，因为容器中的push_back操作需要调用scoped_ptr的=运算符重载函数，结果就是会导致编译失败。虽然scoped_ptr不能转移控制权，但是它们可以交换共享权。scoped_ptr离开作用域之前也是可以显式销毁它们所管理的对象的。调用它的reset方法即可。   

在以下情况时使用scoped_ptr：
1.在可能有异常抛出的作用域里使用指针
2.函数里有几条控制路径
3.动态分配对象的生存期应被限制于特定的作用域内
4.异常安全非常重要时(始终如此!)   

### c++11之enable_shared_from_this   
是一个模板类，定义于头文件<memory>，它能让一个已被一个std::shared_ptr管理的对象安全地生成其他额外的std::shared_ptr实例，它们与 pt 共享对象 t 的所有权若一个类T继承 std::enable_shared_from_this<T> ，则会为该类 T 提供成员函数： shared_from_this。   
  在异步调用中，存在一个保活机制，异步函数执行的时间点无法确定，异步函数可能会使用到异步调用之前存在的变量。为了保证该变量在异步函数执期间一直有效，我们可以传递一个指向自身的share_ptr给异步函数，这样在异步函数执行期间share_ptr所管理的对象就不会析构，所使用的变量也会一直有效了（保活。  
    
### C++标准转换运算符reinterpret_cast   
用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expression）有完全相同的比特位。用在任意指针（或引用）类型之间的转换；以及指针与足够大的整数类型之间的转换；从整数类型（包括枚举类型）到指针类型，无视大小。 不可去除const.
